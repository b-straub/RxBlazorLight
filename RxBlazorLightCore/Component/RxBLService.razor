@typeparam TService where TService : RxBLServiceBase
@inherits OwningComponentBase<TService>
@implements IAsyncDisposable

<CascadingValue Value=@Service>
    <CascadingValue Value=@SampleMS>
        @ChildContent
    </CascadingValue>
</CascadingValue>

@code {
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public double SampleMS { get; set; } = 100;

    private IDisposable? _serviceDisposable;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        _serviceDisposable = Service.Subscribe(InvokeStateChanged, SampleMS);
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        if (firstRender)
        {
            Service.OnInitialized();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            await Service.OnInitializedAsync();
        }
    }

    // currently not called see https://github.com/dotnet/aspnetcore/issues/25873
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    public async ValueTask DisposeAsync()
    {
        await DisposeAsyncCore().ConfigureAwait(false);

        Dispose(false);
        GC.SuppressFinalize(this);
        // Call explicitly see https://github.com/dotnet/aspnetcore/issues/25873
        (this as IDisposable).Dispose();
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _serviceDisposable?.Dispose();
            Service.OnDisposed();
        }

        base.Dispose(disposing);
    }

    protected virtual async Task DisposeAsyncCore()
    {
        await Service.OnDisposedAsync();
    }

    private void InvokeStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }
}
